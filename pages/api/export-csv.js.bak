import { supabase } from '../../lib/supabase'
import Sentry from '../../lib/sentry';

export default async function handler(req, res) {
  const { table_id } = req.query
  if (req.method !== 'GET') { res.setHeader('Allow',['GET']); return res.status(405).end() }
  if (!table_id) return res.status(400).send('table_id required')

  // fields (ordered)
  const { data: fields, error: fErr } = await supabase
    .from('fields').select('*').eq('table_id', table_id)
    .order('position', { ascending: true, nullsFirst: false })
    .order('created_at', { ascending: true })
  if (fErr) return res.status(500).send(fErr.message)

  // records
  const { data: recs, error: rErr } = await supabase.from('records').select('*').eq('table_id', table_id).order('created_at',{ascending:true})
  if (rErr) return res.status(500).send(rErr.message)
  const ids = recs.map(r => r.id)
  const { data: vals, error: vErr } = await supabase.from('record_values').select('*').in('record_id', ids)
  if (vErr) return res.status(500).send(vErr.message)

  // flatten
  const header = ['record_id', ...fields.map(f => f.name)]
  const rows = recs.map(r => {
    const obj = { record_id: r.id }
    for (const f of fields) {
      const cell = (vals || []).find(v => v.record_id === r.id && v.field_id === f.id)
      const raw = cell?.value
      obj[f.name] = (raw == null) ? '' : (typeof raw === 'object' ? JSON.stringify(raw) : String(raw))
    }
    return obj
  })

  const esc = (s) => `"${String(s).replace(/"/g, '""')}"`
  const csv = [header.map(esc).join(',')]
    .concat(rows.map(r => header.map(h => esc(r[h] ?? '')).join(',')))
    .join('\r\n')

  res.setHeader('Content-Type', 'text/csv; charset=utf-8')
  res.setHeader('Content-Disposition', `attachment; filename="export_${table_id}.csv"`)
  return res.status(200).send(csv)
}
