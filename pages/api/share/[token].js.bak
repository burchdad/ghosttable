import { supabase } from '../../../lib/supabase'

export default async function handler(req, res) {
  const { token } = req.query
  if (req.method !== 'GET') { res.setHeader('Allow',['GET']); return res.status(405).end() }

  // validate token
  const { data: links, error: lErr } = await supabase
    .from('share_links').select('*').eq('token', token).limit(1)
  if (lErr) return res.status(500).json({ error: lErr.message })
  const link = links?.[0]
  if (!link) return res.status(404).json({ error: 'Not found' })
  if (link.expires_at && new Date(link.expires_at) < new Date()) {
    return res.status(410).json({ error: 'Link expired' })
  }

  // fetch fields & records for the table
  const { data: fields, error: fErr } = await supabase
    .from('fields').select('*').eq('table_id', link.table_id)
    .order('position', { ascending:true, nullsFirst:false })
    .order('created_at', { ascending:true })
  if (fErr) return res.status(500).json({ error: fErr.message })

  const { data: recs, error: rErr } = await supabase
    .from('records').select('*').eq('table_id', link.table_id)
    .order('created_at', { ascending: true })
  if (rErr) return res.status(500).json({ error: rErr.message })

  const ids = recs.map(r => r.id)
  const { data: vals, error: vErr } = await supabase
    .from('record_values').select('*').in('record_id', ids)
  if (vErr) return res.status(500).json({ error: vErr.message })

  // pack rows with values
  const rows = recs.map(r => ({
    ...r,
    values: (vals || []).filter(v => v.record_id === r.id)
  }))

  // include saved view config if any
  let view = null
  if (link.view_id) {
    const { data: views } = await supabase.from('views').select('*').eq('id', link.view_id).limit(1)
    view = views?.[0] || null
  }

  return res.status(200).json({
    table_id: link.table_id,
    allow_download: !!link.allow_download,
    view,
    fields,
    rows
  })
}
